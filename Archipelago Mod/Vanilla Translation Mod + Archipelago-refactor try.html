<!DOCTYPE html>
<html>
	<head>
        <title>Archipelago - Stick Ranger</title>
        <style>
			body {
				margin: 0;
				overflow: hidden;
				background: #0f0f0f;
				display: flex;
			}
            #cv:-webkit-full-screen {
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
                -ms-interpolation-mode: nearest-neighbor;
                background-color: black;
                object-fit: contain;
                position: fixed;
                width: 100%;
                height: 100%;
            }
			#sidebar {
				width: 256px;
				background: rgb(51, 51, 51);
				color: white;
				display: flex;
				flex-direction:column;
				align-items: center;
				float:right; 
				box-sizing: border-box;
			}
			#chat {
				width: 244px;
				height: 100%;
				overflow-y: auto;
				border: 2px solid rgb(76, 76, 76);
				border-radius: 3px;
				padding: 4px;
				font: 0.9em monospace;
			}
			#saveCode {
				position: absolute;
				bottom: 8px;
				left: 8px;
			}
        </style>
	</head>

	<body>
		<div>
			<div id="disable_electron_warnings">
				<script type="text/javascript">process.env['ELECTRON_DISABLE_SECURITY_WARNINGS'] = 'true';</script>
			</div>
			<canvas id="cv"></canvas>
			<script src="Archipelago Mod.js"></script>
			<script type="text/javascript">Init("1",1,0);</script>
			<div id="saveCode" style="width:512px;">
				<script type="text/javascript">
					function saveCode(){
						var save_html = '';
						save_html += '<table class="ctbl"><tr><td><textarea id="inputBox" rows="1" cols="48" onclick="this.select();"><\/textarea><\/td>';
						save_html += '<td><input type="submit" value="Get" onclick="getCode()" onmousedown="document.getElementById(\'inputBox\').value=\'\';">';
						save_html += '<input type="submit" value="Set" onclick="load()";><\/td><\/tr><br>';

						document.getElementById('saveCode').innerHTML = save_html;
					}
					saveCode();
				</script>
				<script type="text/javascript">
					function getCode(){
						var save_string = GameSave('0');

						if(save_string!='')
							document.getElementById('inputBox').value = save_string;
					}

					function load(){
						document.getElementById('inputBox').value = document.getElementById('inputBox').value.replace(/\x0D\x0A|\x0D|\x0A/g,'');
						var save_string = document.getElementById('inputBox').value;

						if(save_string!='')
							GameLoad(save_string);
					}
				</script>
			</div>
			<div id="fullScreenButton">
				<input type="submit" value="Full Screen" onclick="fullScreen();" />
			</div>
		</div>

		<div id="sidebar">
			<div id="APConnection">
				<p>Archipelago connection</p>
				<table>
					<tr>
						<td>Host:</td>
						<td><input id="host" value="archipelago.gg"></td>
					</tr>
					<tr>
						<td>Port:</td>
						<td><input id="port"></td>
					</tr>
					<tr>
						<td>Slot name:</td>
						<td><input id="slotName"></td>
					</tr>
					<tr>
						<td>Password:</td>
						<td><input id="password" type="password"></td>
					</tr>
				</table>
				<button id="connect">Connect</button>
			</div>
			<div id="chat"></div>

			<script type="module">
				import {
					Client,
					ITEMS_HANDLING_FLAGS,
					SERVER_PACKET_TYPE,
					CLIENT_STATUS
				} from "https://unpkg.com/archipelago.js@1.0.0/dist/archipelago.js";

				// --- IndexedDB helpers ---
				function openDB() {
					return new Promise((res, rej) => {
					const req = indexedDB.open("StickRangerAP", 1);
					req.onupgradeneeded = () => req.result.createObjectStore("savegames");
					req.onsuccess  = () => res(req.result);
					req.onerror    = () => rej(req.error);
					});
				}

				async function getState(key) {
					const db = await openDB();
					return new Promise((res, rej) => {
					const tx = db.transaction("savegames", "readonly");
					const req = tx.objectStore("savegames").get(key);
					req.onsuccess = () => res(req.result);
					req.onerror   = () => rej(req.error);
					});
				}

				async function setState(key, val) {
					const db = await openDB();
					return new Promise((res, rej) => {
					const tx = db.transaction("savegames", "readwrite");
					tx.objectStore("savegames").put(val, key);
					tx.oncomplete = () => res();
					tx.onerror    = () => rej(tx.error);
					});
				}
				// ---------------------------

				class APIntegration {
					//TODO's: Chat needs to be contained to a max height
					//Re-send Stages when making a new game after obtaining locations
					//Do something about localstorage... (cache on disk, like heretic?) with unique id (slot+port+timestamp?)
					constructor() {
						this.STAGE_COMPLETE_OFFSET = 10000;
						this.BOOK_OFFSET = 10100;
						this.LOC_OFFSET = 11000;
						this.ITEM_OFFSET = 12000;
						this.INV_START = 16;
						this.MOUSE_SLOT = 40;
						this.STAGE_TO_WIN = 88; // Hell Castle ID

						this.receivedItems = [];
						this.pendingItems = [];
						this.prevStage = [...Stage_Status];
						this.winReported = false;
						this.lastSequence = -1;
						this.storageKey = '';

						this.host = document.getElementById("host");
						this.port = document.getElementById("port");
						this.slotName = document.getElementById("slotName");
						this.password = document.getElementById("password");
						this.connect = document.getElementById("connect");
						this.chat = document.getElementById("chat");
						this.apDiv = document.getElementById('APConnection');

						this.connect.addEventListener("click", () => this._connect());
						window.addEventListener("beforeunload", () => this._onUnload());
						this._tick = this._tick.bind(this);
						this._tickInterval = this._tick.bind(this);
					}

					log(msg) {
						const d = document.createElement("div");
						d.style.borderBottom = "2px solid rgb(44, 44, 44)";
						d.textContent = msg;
						this.chat.append(d);
						this.chat.scrollTop = this.chat.scrollHeight;
					}

					async saveState() {
						if (!this.storageKey) return;
						await setState(this.storageKey, {
							receivedItems: this.receivedItems,
							stages: Stage_Status,
							save: GameSave("0")
						});
					}

					_onUnload() {
						clearInterval(this._tickInterval);
						this.saveState();
						this.client?.disconnect();
					}

					async _connect() {
						this.client = new Client();
						const connectionInfo = {
							hostname: this.host.value,
							port: parseInt(this.port.value),
							game: "Stick Ranger",
							name: this.slotName.value,
							password: this.password.value,
							items_handling: ITEMS_HANDLING_FLAGS.REMOTE_ALL,
						};

						this.storageKey = [
							connectionInfo.hostname,
							connectionInfo.port,
							connectionInfo.game,
							connectionInfo.name
						].join(":");

						this.client.addListener(SERVER_PACKET_TYPE.CONNECTED, async () => {
							const saved = await getState(this.storageKey);
							if (saved) {
								this.receivedItems = saved.receivedItems || [];
								GameLoad(saved.save.replace(/\x0D\x0A|\x0D|\x0A/g, ""));
								this.receivedItems.forEach(id => this._applyItem(id));
								Stage_Status = saved.stages || Stage_Status;
							} else {
								this.saveState();
							}
							this._tickInterval = setInterval(this._tick, 200);
						});

						this.client.addListener(SERVER_PACKET_TYPE.RECEIVED_ITEMS, async packet => {
							const serverItems = packet.items.map(it => it.item);
							serverItems.forEach(id => this._applyItem(id));
							this.receivedItems = Array.from(new Set([...this.receivedItems, ...serverItems]));
							this.saveState();
						});

						this.client.addListener(SERVER_PACKET_TYPE.PRINT_JSON, packet => {
							const text = packet.data.map(el => {
								const id = Number(el.text);
								let pid = this.client.data.slotData.player_id;
								if (el.player !== undefined) pid = Number(el.player);
								if (el.type === "player_id") return this.client.players.name(id);
								if (el.type === "item_id") return this.client.items.name(this.client.players.game(pid), id);
								if (el.type === "location_id") return this.client.locations.name(this.client.players.game(pid), id);
								if (el.text) return el.text;
								return el.text || "";
							}).join(" ");
							if (text) this.log(text);
						});

						this.client.connect(connectionInfo);
						this.connect.disabled = true;
						this.host.disabled = true;
						this.port.disabled = true;
						this.slotName.disabled = true;
						this.password.disabled = true;
						this.apDiv.style.display = "none";
					}

					sendLocation(id) {
						if (this.client) this.client.locations.check(id);
						this.saveState();
					}

					_applyItem(id) {
						// location unlock
						if (id >= this.LOC_OFFSET && id < this.LOC_OFFSET + 999) {
							Stage_Status[id - this.LOC_OFFSET] |= Unlocked;
						}

						// item grant
						else if (id >= this.ITEM_OFFSET && id < this.ITEM_OFFSET + 999) {
							const idx = id - this.ITEM_OFFSET;
							const slot = this._firstEmptyInvSlot();
							if (slot >= 0) Item_Inv[slot] = idx;
							else this.pendingItems.push(idx);
						}

						// something wrong
						else {
							this.log("Tried to receive id: " + id + ", but that failed, let the developer know!");
						}

						this.saveState();
						antiCheatSet();
					}

					_firstEmptyInvSlot() {
						for (let i = this.INV_START; i < Item_Inv.length; i++) {
							if (i === this.MOUSE_SLOT) continue;
							if (!Item_Inv[i]) return i;
						}
						return -1;
					}

					_flushPending() {
						let slot;
						while (this.pendingItems.length && (slot = this._firstEmptyInvSlot()) >= 0) {
							Item_Inv[slot] = this.pendingItems.shift();
							this.saveState();
							antiCheatSet();
						}
					}

					_tick() {
						// scan beaten/booked changes
						for (let i = 0; i < Stage_Status.length; i++) {
							if ((this.prevStage[i] & Beaten) === 0 && (Stage_Status[i] & Beaten) !== 0) {
								this.sendLocation(i + this.STAGE_COMPLETE_OFFSET);
							}
							if ((this.prevStage[i] & Booked)===0 && (Stage_Status[i] & Booked) !== 0) {
								this.sendLocation(i + 10100);
							}
						}
						this.prevStage = [...Stage_Status];

						// flush inventory
						this._flushPending();

						// report win
						if (!this.winReported && (Stage_Status[this.STAGE_TO_WIN] & Beaten) === Beaten) {
							this.winReported = true;
							this.client?.send({
								cmd: "StatusUpdate",
								status: 30
							});
						}

						if (Sequence_Step === 6 && this.lastSequence < 6) {
							this.receivedItems.forEach(id => this._applyItem(id));
						}
						this.lastSequence = Sequence_Step;
					}
				}

				window.ap = new APIntegration();
			</script>
		</div>
	</body>
</html>